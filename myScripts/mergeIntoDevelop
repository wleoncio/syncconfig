#!/usr/bin/bash
source uio-colors.sh

version="1.2.0 licensed under GPLv3"

usage() {
  less << EOU
Usage:
  $(basename $0) [--dry-run] [--target BRANCH]
  $(basename $0) -h | --help
  $(basename $0) --version

Options:
  --target BRANCH  Branch to merge into [default, in order: develop, main, master]
  --dry-run        Show what would be done, without making any changes
  -h --help        Show this help message and exit
  --version        Show version and exit

Examples:
  $(basename $0) --skip-cov
  $(basename $0) --target the-main-branch
EOU
}

# Check if docopts is installed
if ! command -v docopts &> /dev/null; then
  echo "${roed}Error: docopts is not installed.${reset}"
  exit 2
fi

# Setting variables
eval "$(docopts -A ARGS -h "$(usage)" -V "$version" : "$@")"

covr=true
if [[ "${ARGS['--skip-cov']}" ]]; then
    covr=false
fi

# Determine target branch: use --target, or search for local develop/main/master
if [[ -n "${ARGS['--target']}" ]]; then
	target_branch="${ARGS['--target']}"
else
	branches=$(git branch --list)
	if echo "$branches" | grep -q develop; then
		target_branch="develop"
	elif echo "$branches" | grep -q main; then
		target_branch="main"
	elif echo "$branches" | grep -q master; then
		target_branch="master"
	else
		echo "Error: No suitable base branch found (develop, main, or master). Please specify a branch."
		exit 1
	fi
fi

# Warn if the user entered a non-existent branch (before proceeding)
if ! git branch --list | grep -q "$target_branch"; then
	echo -e "${roed}Error: Branch '$target_branch' does not exist locally.${reset}"
	exit 1
else
	echo -e "\nUsing target branch: ${blaa}${target_branch}${reset}"
fi

feature_branch=$(eval git branch --show-current)

# Check for changes in file containing a "version" variable
changed_files=$(git diff --name-only $target_branch..$feature_branch)
version_related=false
for f in $changed_files; do
	if grep "^version=" --ignore-case "$f" &> /dev/null; then
		version_related=true
		break
	fi
done

if [ "$version_related" = true ]; then
	for f in $changed_files; do
		if grep "^version=" --ignore-case "$f" &> /dev/null; then
			version_bump_found=false
			commits=$(git log --format="%H" $target_branch..$feature_branch -- "$f")
			for c in $commits; do
				diff_output=$(git show "$c" -- "$f")
				# Look for consecutive -version/+version lines
				if echo "$diff_output" | awk '/^-version/ {prev=1; next} /^\+version/ {if(prev==1){found=1}; prev=0} {prev=0} END{exit !found}'; then
					version_bump_found=true
					break
				fi
			done
			if [ "$version_bump_found" = false ]; then
				echo -e "${oransje}Warning: '$f' changed and contains 'version', but no commit detected bumping the version.${reset}"
			fi
		fi
	done
fi

# Making sure pre-work is done

unstaged=$(eval git status --short)
if [ -n "$unstaged" ]; then
	echo "Unstaged modifications:"
	git status --short
	echo
	read -p "Press enter to continue, Ctrl+C to cancel"
fi

check_file=/tmp/merge_check.txt
git log --oneline $target_branch.. | grep -i -e "squash!" -e "fixup!" > $check_file
if [ -s "$check_file" ]; then
	echo -e "${roed}Error: There are squash or fixup commits on the feature branch."
	echo -e "Please clean up your history before merging. Run this for example:${reset}"
	echo -e "${bold}git rebase --interactive --autosquash ${target_branch}${reset}"
	exit 1
fi

echo -e "\nMerging ${blaa}${feature_branch}${reset} into ${blaa}${target_branch}${reset}. Did you remember to:"

echo -e "- Add unit ${roed}tests${reset} for new code?"
if [[ $covr == true && -f "DESCRIPTION" ]]; then
	echo -n "  Calculating package coverage on merge: "
	cvrg=$(Rscript -e "cat(round(covr::percent_coverage(covr::package_coverage()), 2))")
	echo -e "${roed}$cvrg %${reset}"
fi

if [[ -f "NEWS.md" ]]; then
	echo -e "- Update ${roed}NEWS.md${reset} (see head below)?"
	echo -e "${blaatone_bg}"
	awk '/^#/ {c++; if (c==2) {exit}} {print}' NEWS.md
	echo -e "${reset}\n"
else
	echo -e "- ${roed}No NEWS.md${reset} found. Consider using one!"
fi

echo -e "- Updated the software ${roed}version${reset}?"
echo
read -p "Press enter to continue, Ctrl+C to cancel"

# Performing the merge (if not a dry run)
if [[ "${ARGS['--dry-run']}" == true ]]; then
	echo -e "\n${oransje}Dry run: No changes made. Exiting.${reset}"
	exit 0
fi
git checkout $target_branch
git merge $feature_branch --log

exit 0
